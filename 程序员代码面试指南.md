## 程序员代码面试指南

### 1可见山峰对的数量

​		一个不含有负数的数组可以代表一圈环形山，每个位置的值代表山的高度。有两个方向：next方向(逆时针方向)，last方向(顺时针)。

山峰A和山峰B相互看见的条件为：

1. 如果A和B是同一座山，认为不能相互看见
2. 如果A和B是不同的山，并且在环中相邻，认为可以相互看见
3. 如果A和B是不同的山，并且在环中不相邻，假设两座山峰高度的最小值为min。如果A通过next或last方向到B的途中没有高度比min大的山峰，则认为A和B可以相互看见。

给定一个不含有负数且没有重复值的数组arr，请返回有多少对山峰能够相互看见。

**进阶问题**：给定一个不含有负数但可能含有重复值的数组arr，返回有多少对山峰能够互相看见

### 思路

<font color='red'>首先结果与数组内的数如何排列不会有关系。</font>

<font color='red'>不要管相邻不相邻，都是陷阱。</font>

采用由小找大的思路，假设山峰k的高度不是最大值和次大值，那么他在环状山中向自身左右2个方向找，一定能分别找到一个高度大于他自身的山峰H，找到的山峰H和山峰k自身组成一对（相邻也不相邻没关系）。山峰H后面的山不管怎么样都不再满足与山峰k可见的条件（山峰k被山峰H挡住了），山峰H前的山峰L是可能与山峰k可见的，但是这些都比山峰k的高度低，考虑这里由大到小的山峰对会在最后结果中重复，因此也不用管。所以一个这个的山峰K能产生2个可见山峰对。显然不是最高和第二高的山峰k总共有n-2个，能有2*(n-2)个山峰对，另外第二高的山能找到最高的组成一对，最高的找不到更高的了。所以最后结果是2*(n-2)+1	..。。。

<hr>

进阶：数组中有重复的数。

借助栈，仍然小找大，从最大值的地方开始遍历一圈回到最大值时结束。栈中存储的是（value，times），遍历时，遍历数组中值与栈顶元素相同则times+1，比栈顶value小则入栈，比栈顶value大则栈顶元组出栈。出栈时计算山峰对。

遍历阶段有元素出栈，说明出栈元素在两边都有大于他的值。由上面思路的推论，考虑的找到比他大的，增加2*times个可见山峰对。考虑自身高度组成的对。既times个中任2个组合C(2,times)。特别的，times=1时，没有2个自身高度组成可见山峰对，C(2,times)=0.既res+=C(2,times)+2*times

遍历阶段结束后，栈中肯定还有元素。开始清算出栈。分三种情况：1，出栈元素不是栈低也不是倒数第二个。此时出栈增加的可见山峰对计算方法跟遍历阶段相同，因为他也能在两边找到比他大的元素。2，出栈元素倒数第二个，这个时候就看最后一个元素的times是否大于1，大于1则计算方法仍然同上，理由同上。等于1的情况下res+=C(2,times)+times，只能找到一个比他大的元素，所以不乘2了。 3，最后一个元素出栈，直接res+=C(2,times)，找不到比他更大的元素，只算内部组成。

over。







