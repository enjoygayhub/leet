###  100开始

<details>
<summary>101,对称的树<summary>

题目：给定一个二叉树，检查它是否是镜像对称的
```python
class Solution:  # 递归
    def isSymmetric(self, root: TreeNode) -> bool:
        return not root or self.is_mirror(root.left, root.right)
    def is_mirror(self, tree1: TreeNode, tree2: TreeNode) -> bool:
        if not tree1 and not tree2:
            return True
        if not tree1 or not tree2 or tree1.val != tree2.val:
            return False
        return self.is_mirror(tree1.left, tree2.right) and self.is_mirror(tree1.right, tree2.left)
    
class Solution:  # 循环
    def isSymmetric(self, root: TreeNode) -> bool:
        if root==None:
            return True
        stack=[(root.left,root.right)]
        while stack:
            l,r=stack.pop()
            if l==None and r==None:
                continue
            if l==None or r==None:
                return False
            if l.val!=r.val:
                return False
            stack.append((l.left,r.right))
            stack.append((l.right,r.left))
        return True
    
```
</details>
<details>
<summary>102,二叉树层次遍历<summary>

题目：给你一个二叉树，请你返回其按 层序遍历 得到的节点值（即逐层地，从左到右访问所有节点）。
```python 
class Solution:  # 使用队列
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        queue = collections.deque([root])
        res = []
        while queue:
            level = []
            for _ in range(len(queue)):
                node = queue.popleft()
                level.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(level)
        return res   
```
</details>
<details>
<summary>103,二叉树锯齿层次遍历<summary>

题目：给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
方法一，与102题一样BSF，遇到偶数层将level列表反转
方法二，DSF，为每一层建一个双端列表，奇数层使用append，偶数层头插appendleft。
```python    
class Solution:
    def zigzagLevelOrder(self, root):
        if root is None:
            return []
        results = []
        def dfs(node, level):
            if level >= len(results):
                results.append(collections.deque([node.val]))
            else:
                if level % 2 == 0:
                    results[level].append(node.val)
                else:
                    results[level].appendleft(node.val)

            for next_node in [node.left, node.right]:
                if next_node is not None:
                    dfs(next_node, level+1)

        dfs(root, 0)
        return results 
```
</details>
<details>
<summary>104,二叉树最大深度，111二叉树的最小深度<summary>

题目：给你一个二叉树，最大深度。max换成min可得最小深度
```python 
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if root is None:
            return 0
        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))
```
</details>
<details>
<summary>105,已知先序，中序构建二叉树106.中序和后序构造二叉树<summary>

题目：先序遍历的第一个肯定是根，后续遍历最后一个是根节点。
```python 
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        if not preorder:
            return None
        else:
            root=TreeNode(preorder[0])
            i=inorder.index(preorder[0])
            root.left=self.buildTree(preorder[1:i+1],inorder[:i])
            root.right=self.buildTree(preorder[i+1:],inorder[i+1:])
            return root
```
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:
        map_inorder = {}
        for i, val in enumerate(inorder): 
            map_inorder[val] = i
            
        def recur(low, high):
            if low > high: return None
            x = TreeNode(postorder.pop())
            mid = map_inorder[x.val]
            x.right = recur(mid+1, high)
            x.left = recur(low, mid-1)
            return x
        return recur(0, len(inorder)-1)
</details>
<details>
<summary>108,有序数组转化为二叉搜索树，109有序链表转化为二叉搜索树<summary>

题目：给定一个有序数组，转化为一个平衡二叉平衡树.109题也可以先链表转化成数组再按108题得解法做。
```python 
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        if not nums:
            return None
        i=len(nums)//2
        root=TreeNode(nums[i])
        root.left=self.sortedArrayToBST(nums[:i])
        root.right=self.sortedArrayToBST(nums[i+1:])
        return root
```
class Solution:    #  DFS遍历，可得中序遍历
    def sortedListToBST(self, head: ListNode) -> TreeNode:
        def getLength(head: ListNode) -> int:
            ret = 0
            while head:
                ret += 1
                head = head.next
            return ret
        def buildTree(left: int, right: int) -> TreeNode:
            if left > right:
                return None
            mid = (left + right + 1) // 2
            root = TreeNode()
            root.left = buildTree(left, mid - 1)
            nonlocal head
            root.val = head.val   # 递归过程中构建树，dsf中序遍历，第一个访问得肯定head 
            head = head.next
            root.right = buildTree(mid + 1, right)
            return root
        
        length = getLength(head)
        return buildTree(0, length - 1)
</details>
<details>
<summary>110,平衡二叉树<summary>

题目：给定一个二叉树，判断它是否是高度平衡的二叉树。
一棵高度平衡二叉树定义为：
一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。
```python 
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        if not root: return True
        self.flag = False
        self.getHeight(root)
        return not self.flag

    def getHeight(self, root):  # 递归访问，求深度，设置平衡flag
        if not root: return 0
        left = self.getHeight(root.left)
        right = self.getHeight(root.right)

        if abs(left - right) > 1 or self.flag:
            self.flag = True
        return max(left, right) + 1
```
</details>
<details>
<summary>112,路径总和，113路径总和2<summary>

题目：给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。
一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。
解：112要求终点必是叶子结点，且必须由根结点出发。113给出所有满足要求的路径
```python 
class Solution(object):
    def hasPathSum(self, root, sum):
        if not root:
            return False
        if root.left==None and root.right==None and root.val==sum:return True
        else:
            return self.hasPathSum(root.left,sum-root.val) or self.hasPathSum(root.right,sum-root.val)
            
class Solution:
    def pathSum(self, root: TreeNode, sum: int) -> List[List[int]]:
        res=[]
        path=[]
        def help(pa,root,val):
            if not root:
                return
            if not root.left and not root.right and root.val==val:
                res.append(pa+[val])
                return 
            help(pa+[root.val],root.left,val-root.val)
            help(pa+[root.val],root.right,val-root.val)
        
        help(path,root,sum)
        return res                
```
</details>
<details>
<summary>120.三角形最小路径和<summary>

题目：给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。
一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。

解：跟112类似。使用动态规划，自上而下，dp【i】= triangle [i][j]+ min（ dp【i】，dp【i-1】）,特殊处理i=0时的状态转移。空间复杂度On。因为是数组存储，如果可以改变原数组可以节省空间，自下而上原地操作。
```python 
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        n=len(triangle)-1
        for i in range(n-1,-1,-1):
            for j in range(1+i):
                triangle[i][j]+=min(triangle[i+1][j],triangle[i+1][j+1])
        
        return triangle[0][0]        
```
</details>
<details>
<summary>114,二叉树展开为列表<summary>

题目：给定一个二叉树，原地展开为单链表。
思路：存在分叉时，找到当前结点在中序遍历中的前一个结点pre，将当前结点左子树转为右子树，原右子树接到pre后。
```python 
class Solution:
    def flatten(self, root: TreeNode) -> None:
        curr = root
        while curr:
            if curr.left:  # 存在左结点则说明有分支
                predecessor = nxt = curr.left
                while predecessor.right:
                    predecessor = predecessor.right
                predecessor.right = curr.right
                curr.left = None
                curr.right = nxt
            curr = curr.right
class Solution:  # 方法二，递归后续遍历
    tail=None
    def flatten(self, root: TreeNode) -> None:
        if not root:
            return
        self.flatten(root.right)
        self.flatten(root.left)
        root.left=None
        root.right=self.tail
        self.tail=root
```
</details>
<details>
<summary>116, 填充每个节点的下一个右侧节点指针<summary>

题目：116，给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
117，不再是满二叉树。
```python 
class Solution:  #116循环方法
    def connect(self, root: 'Node') -> 'Node':
        if not root:
            return root
        leftmost = root
        while leftmost.left:  # 每层最左侧的结点开始
            head = leftmost
            while head:
                head.left.next = head.right
                if head.next:
                    head.right.next = head.next.left
                head = head.next
            leftmost = leftmost.left
        return root
class Solution:  # 116递归方法，每次链接左到到右，和右到next的左
    def connect(self, root: 'Node') -> 'Node':
        if root and root.left:
            root.left.next = root.right
            if root.next:
                root.right.next = root.next.left
            self.connect(root.left)
            self.connect(root.right)
        return root
        
```


```javascript
//117题可以采用层次遍历，然后将一层的结点连起来，空间复杂度是On。采用已建立的next遍历可省去队列，
let last = null, nextStart = null;//全局遍量
const handle = (p) => {
    if (last !== null) {
        last.next = p;//链接
    } 
    if (nextStart === null) {
        nextStart = p;//设置下一层的起始位置
    }
    last = p;
}
var connect = function(root) {
    if (root === null) {
        return null;
    }
    let start = root;
    while (start != null) {
        last = null;
        nextStart = null;//每层遍历前置空
        for (let p = start; p !== null; p = p.next) {//当前层遍历
            if (p.left !== null) {
                handle(p.left);
            }
            if (p.right !== null) {
                handle(p.right);
            }
        }
        start = nextStart;
    }
    return root;
};
```
</details>
<details>
<summary>118,杨辉三角，119杨辉三角2<summary>

题目：给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。
```python 
class Solution(object):
    def generate(self, numRows):
        res = []
        for i in range(0, numRows):
            res.append([1]*(i+1))
            for j in range(1, i):
                res[i][j] = res[i-1][j-1] + res[i-1][j]
        return res
class Solution(object):  # 117题数学方法
    def getRow(self, rowIndex):
        
        from math import factorial as f
        return [f(rowIndex) // (f(i) * f(rowIndex-i)) for i in range(rowIndex + 1)]
```

```javascript
var getRow = function(rowIndex) { //117题正经方法
    var res = [1];
    for(let i=1;i<rowIndex+1;i++){
        res.unshift(0);
        for(let j=0;j<i;j++){
            res[j]=res[j]+res[j+1];
        }
    }
    return res
};
```
</details>

<details>
<summary>121，122买卖股票系列题<summary>

题目：给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。
121只能完成一次交易，k=1，求最大收益。

```python 
class Solution:  # 121方法一找买入点
    def maxProfit(self, prices: List[int]) -> int:
        if not prices:
            return 0
        min=prices[0]
        profit=0
        for i in prices:
            if i<min:
                min=i
            else:
                profit=max(i-min,profit)
        return profit
```
```javascript
var maxProfit = function(prices) { // 121方法二，转化为每天的利润，求最大
    let res =0;
    let pre = 0; // pre表示如果前一天卖出的最大利润
    for(let i = 1;i<prices.length;i++){
        if (prices[i]>prices[i-1]){
            res=Math.max(res,pre+prices[i]-prices[i-1]);   
        }
        pre += prices[i]-prices[i-1];
        pre=Math.max(0,pre);   
    }
    return res;
};
```
122题可以多次交易，k=任意，高抛低吸。理论上讲每次涨都能吃到，每次跌都能避开，就能实现最大收益。

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n=len(prices)
        for i in range(n-1):
            if prices[i]<prices[i+1]:
                prices[i]=prices[i+1]-prices[i]
            else:
                prices[i]=0
        return sum(prices[:n-1])
```

123题，最多2次交易。即k=2.

188题，交易次数给定。k=k。

```python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        if not prices: return 0
        n = len(prices)
        if k >= n//2: # k大于一半长度了，相当于可以无限次交易了，退化为第122题
            res = 0
            for i in range(1,n):
                if prices[i] > prices[i-1]:
                    res += prices[i] - prices[i-1]
            return res
        else:
            dp = [[[0 for i in range(2)]  for _ in range(k+1)] for _ in range(n)]
            for t in range(k+1):
                dp[-1][t][1] = -float('inf')
                dp[0][t][1] = -float('inf')
            for i in range(n):
                for j in range(1,k+1):  # k=2时退化为123题
                    dp[i][j][1] = max(dp[i-1][j][1],dp[i-1][j-1][0] - prices[i])#买算1次
                    dp[i][j][0] = max(dp[i-1][j][0],dp[i-1][j][1] + prices[i])
            return dp[-1][-1][0]

```

309题，有冷却期。卖出后经过x天后才能买，此题中x=1.

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices:
            return 0 
        n=len(prices)
        benifit=[0]*n  # 代表第i天卖出，或者不交易盈利
        cost=[0]*n  # 代表第i天买入或者不交易的盈利，负值代表成本
        cost[0]=-prices[0]
        for i in range(1,n):
            benifit[i]=max(benifit[i-1],prices[i]+cost[i-1])
            cost[i]= max(cost[i-1],benifit[i-2]-prices[i])  # i-2表示前天卖出，今天买入
        return benifit[-1]

```

714 含手续费 在309题的基础上-fee就可

```python
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        if not prices: return 0
        n = len(prices)
        dp =[ [0,0] for _ in range(n)]
        dp[-1][1] = -float('inf')
        dp[0][1] = -float('inf')
        for i in range(n):
            dp[i][0] = max(dp[i-1][0],dp[i-1][1] + prices[i] -fee)
            dp[i][1] = max(dp[i-1][1],dp[i-1][0] - prices[i])
        return dp[-1][0]
```
</details>
<details>
<summary>118验证回文串，680验证回文字符串2<summary>

题目：只判断数字和字母。680要求最多删除一个字母后保证回文
```python 
class Solution:
    def isPalindrome(self, s: str) -> bool:
        s = ''.join(filter(str.isalnum, s)).lower()
        return s == s[::-1]
        
class Solution:  # 680题，先找到不同的位置
    def validPalindrome(self, s: str) -> bool:
        i=0
        j=len(s)-1
        while i<j:
            if s[i]==s[j]:
                i+=1
                j-=1
            else:
                return s[i:j]==s[i:j][::-1] or s[i+1:j+1]==s[i+1:j+1][::-1]
        return True
```
</details>
<details>
<summary>127，单词接龙<summary>

题目：bsf。
```python 
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        
        wordList = set(wordList)
        queue = collections.deque([[beginWord, 1]])
        while queue:
            word, length = queue.popleft()
            if word == endWord:
                return length
            for i in range(len(word)):
                for c in 'abcdefghijklmnopqrstuvwxyz':
                    next_word = word[:i] + c + word[i+1:]
                    if next_word in wordList:
                        wordList.remove(next_word)
                        queue.append([next_word, length + 1])
        return 0
```
</details>

<details>
<summary>128，最长连续序列<summary>

题目：给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。你可以设计并实现时间复杂度为 O(n) 的解决方案吗？
题目要求复杂度n，答案是哈希表。关键在于num-1如果在表中，则跳过对num的搜索。避免 了重复搜素。减小复杂度到n
```python 
class Solution:
    def longestConsecutive(self, nums):
        longest_streak = 0
        num_set = set(nums)

        for num in num_set:
            if num - 1 not in num_set:
                current_num = num
                current_streak = 1

                while current_num + 1 in num_set:
                    current_num += 1
                    current_streak += 1

                longest_streak = max(longest_streak, current_streak)

        return longest_streak
```
</details>

<details>
<summary>129，求根结点到叶子结点的数字之和<summary>

题目：给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。
```python 
class Solution:
    def sumNumbers(self, root: TreeNode) -> int:
        nums=[0]
        def help(root,total=0):
            total=10*total+root.val
            if not root.left and not root.right:
                nums.append(total)
                return
            if root.left:
                help(root.left,total)
            if root.right:
                help(root.right,total)
        if root:
            help(root)
        return sum(nums)
```
</details>

<details>
<summary>130，被围绕的区域<summary>

题目：给定一个二维的矩阵，包含 'X' 和 'O'（字母 O）。
找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。
```python 
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        if not any(board): return
        m, n = len(board), len(board[0])
        save = [ij for k in range(max(m,n)) for ij in ((0, k), (m-1, k), (k, 0), (k, n-1))]
        while save:
            i, j = save.pop()
            if 0 <= i < m and 0 <= j < n and board[i][j] == 'O':
                board[i][j] = 'S'
                save += (i, j-1), (i, j+1), (i-1, j), (i+1, j)

        board[:] = [['XO'[c == 'S'] for c in row] for row in board]
```
</details>

<details>
<summary>131，分割回文串<summary>

题目：给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。
返回 s 所有可能的分割方案。
法一递归分解，速度慢。法二，动态规划。快点，对于长度i的串，dp【i】代表已分割的所有方法
对于字符s【i】的加入，新的状态有3种，1是作为单个字符，直接加入末尾，2是前一个也是单个字符，可以合并。3是与倒数第2个相同，可以合并。
```python 
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        res=[]
        def help(lf,part=[]):
            if not lf:
                if part:
                    res.append(part)
                return
            for i in range(len(lf)):
                if lf[:i+1]==lf[:i+1][::-1]:
                    help(lf[i+1:],part+[lf[:i+1]])
        help(s)
        return res
        
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        if s == "":
            return []
        ans = [[s[0]] ]
        for i in range(1, len(s)):
            curr = s[i]
            newAns = []
            for item in ans:
                newAns.append(item + [curr])
                if item[-1] == curr:
                    newAns.append(item[0:-1] + [item[-1] + curr])
                if len(item) >= 2 and item[-2] == curr:
                    newAns.append(item[0:-2] + [item[-2] + item[-1] + curr])
            ans = newAns 
        return ans     
```
</details>
<details>
<summary>132，分割回文串2<summary>

题目：给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。
返回 分割次数最少方案的次数。
本体求次数，用131中的方法求所有分割方案再求最少的次数不再满足时间要求。
```python 
import functools
class Solution:
    @functools.lru_cache(None)
    def minCut(self, s: str) -> int:
        if s == s[::-1]:  # 剩余的本身是回文，不再分割
            return 0
        ans = float("inf")
        for i in range(1, len(s) + 1):
            if s[:i] == s[:i][::-1]:
                ans = min(self.minCut(s[i:]) + 1, ans)
        return ans
        
class Solution:   # 动态规划，与求最长回文串类似，min_s[i]代表长度为i的串的最短分割次数
    def minCut(self, s: str) -> int:
        min_s = list(range(len(s)))  
        n = len(s)
        dp = [[False] * n for _ in range(n)]
        for i in range(n):
            for j in range(i+1):
                if s[i] == s[j] and (i - j < 2 or dp[j + 1][i - 1]):
                    dp[j][i] = True
                    # 说明不用分割
                    if j == 0:
                        min_s[i] = 0
                    else:
                        min_s[i] = min(min_s[i], min_s[j - 1] + 1)
        return min_s[-1]
```
</details>